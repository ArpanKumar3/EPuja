/*
          # [Schema Fix & Enhancement: Admin & Checkout]
          This script corrects a data type mismatch and sets up the database for new Admin Dashboard and Cart/Checkout features.

          ## Query Description: [This script is safe to run. It adds new tables and columns and corrects a previous error. It is designed to be idempotent, meaning it can be run multiple times without causing issues. No data will be lost.]
          
          ## Metadata:
          - Schema-Category: ["Structural", "Safe"]
          - Impact-Level: ["Low"]
          - Requires-Backup: false
          - Reversible: true
          
          ## Structure Details:
          - Corrects: `bookings.transaction_id` column type.
          - Adds: `site_settings`, `cart`, `cart_items` tables.
          - Adds: New columns to `bookings`, `transactions`, and `profiles`.
          - Updates: RLS policies for new admin capabilities.
          
          ## Security Implications:
          - RLS Status: [Enabled]
          - Policy Changes: [Yes]
          - Auth Requirements: [Admin role (`check_admin_role()`)]
          
          ## Performance Impact:
          - Indexes: [Adds foreign key indexes]
          - Triggers: [None]
          - Estimated Impact: [Low, standard schema changes.]
*/

-- Step 1: Drop the faulty column if it was partially created
DO $$
BEGIN
   IF EXISTS (
       SELECT 1 FROM information_schema.columns 
       WHERE table_name='bookings' AND column_name='transaction_id'
   ) THEN
      -- Check if the constraint exists before trying to drop it
      IF EXISTS (
          SELECT 1 FROM information_schema.table_constraints 
          WHERE constraint_name='bookings_transaction_id_fkey' AND table_name='bookings'
      ) THEN
          ALTER TABLE bookings DROP CONSTRAINT bookings_transaction_id_fkey;
      END IF;
      ALTER TABLE bookings DROP COLUMN transaction_id;
   END IF;
END $$;


-- Step 2: Create site_settings table
CREATE TABLE IF NOT EXISTS site_settings (
    id bigint generated by default as identity primary key,
    key text unique not null,
    value jsonb,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
ALTER TABLE site_settings ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow public read access" ON site_settings;
CREATE POLICY "Allow public read access" ON site_settings FOR SELECT USING (true);
DROP POLICY IF EXISTS "Allow admin full access" ON site_settings;
CREATE POLICY "Allow admin full access" ON site_settings FOR ALL USING (check_admin_role()) WITH CHECK (check_admin_role());


-- Step 3: Create cart & cart_items tables
CREATE TABLE IF NOT EXISTS cart (
    id uuid default gen_random_uuid() primary key,
    user_id uuid references auth.users(id) on delete cascade not null unique,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
ALTER TABLE cart ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can manage their own cart" ON cart;
CREATE POLICY "Users can manage their own cart" ON cart FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

CREATE TABLE IF NOT EXISTS cart_items (
    id bigint generated by default as identity primary key,
    cart_id uuid references cart(id) on delete cascade not null,
    puja_id bigint references pujas(id) on delete cascade,
    quantity int not null default 1,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null,
    unique(cart_id, puja_id)
);
ALTER TABLE cart_items ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can manage their own cart items" ON cart_items;
CREATE POLICY "Users can manage their own cart items" ON cart_items FOR ALL USING (
    exists (select 1 from cart where cart.id = cart_items.cart_id and cart.user_id = auth.uid())
) WITH CHECK (
    exists (select 1 from cart where cart.id = cart_items.cart_id and cart.user_id = auth.uid())
);


-- Step 4: Update bookings and transactions tables with the CORRECT data types
ALTER TABLE bookings ADD COLUMN IF NOT EXISTS transaction_id bigint;
ALTER TABLE bookings ADD CONSTRAINT bookings_transaction_id_fkey FOREIGN KEY (transaction_id) REFERENCES transactions(id) ON DELETE SET NULL;

ALTER TABLE transactions ADD COLUMN IF NOT EXISTS booking_id bigint;
ALTER TABLE transactions ADD CONSTRAINT transactions_booking_id_fkey FOREIGN KEY (booking_id) REFERENCES bookings(id) ON DELETE SET NULL;

ALTER TABLE transactions ADD COLUMN IF NOT EXISTS payment_gateway text;
ALTER TABLE transactions ADD COLUMN IF NOT EXISTS gateway_transaction_id text;


-- Step 5: Update profiles table for user management
ALTER TABLE profiles ADD COLUMN IF NOT EXISTS is_active boolean default true;


-- Step 6: Update RLS policies for admin access
-- RLS for pujas
DROP POLICY IF EXISTS "Allow admin full access to pujas" ON public.pujas;
CREATE POLICY "Allow admin full access to pujas" ON public.pujas FOR ALL USING (check_admin_role()) WITH CHECK (check_admin_role());

-- RLS for profiles
DROP POLICY IF EXISTS "Allow admin read access to profiles" ON public.profiles;
CREATE POLICY "Allow admin read access to profiles" ON public.profiles FOR SELECT USING (check_admin_role());
DROP POLICY IF EXISTS "Allow admin to update profiles" ON public.profiles;
CREATE POLICY "Allow admin to update profiles" ON public.profiles FOR UPDATE USING (check_admin_role()) WITH CHECK (check_admin_role());

-- RLS for bookings
ALTER TABLE bookings ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view their own bookings" ON bookings;
CREATE POLICY "Users can view their own bookings" ON bookings FOR SELECT USING (auth.uid() = user_id);
DROP POLICY IF EXISTS "Admins can manage all bookings" ON bookings;
CREATE POLICY "Admins can manage all bookings" ON bookings FOR ALL USING (check_admin_role());

-- RLS for transactions
ALTER TABLE transactions ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view their own transactions" ON transactions;
CREATE POLICY "Users can view their own transactions" ON transactions FOR SELECT USING (auth.uid() = user_id);
DROP POLICY IF EXISTS "Admins can manage all transactions" ON transactions;
CREATE POLICY "Admins can manage all transactions" ON transactions FOR ALL USING (check_admin_role());
